<html>
<head>
	<title>Simple GUI</title>
	<script src="../../pd.js"></script>
    <script src="../../test/lib/jquery-1.7.1.js"></script>
    <script src="../../test/lib/d3.v2.js"></script>
	<script>
        var objType, portletType, proto;

        for (objType in Pd.objects) {
            if (proto = Pd.objects[objType].prototype) {
                Pd.extend(proto, {

                    initGui: function(args) {
                        this._guiData = {
                            x: 0,
                            y: 0,
                            text: this.type + ' ' + args.join(' ')
                        };
                    },

                    getX: function() { return this._guiData.x; },

                    getY: function() { return this._guiData.y; },

                    setPos: function(pos) {
                        // Update the saved position
                        var x = this._guiData.x = (pos.x || this._guiData.x);
                        var y = this._guiData.y = (pos.y || this._guiData.y);
                        // Update the display of the object and all its connections
                        this.d3().attr('transform', gui.translation(x, y));
                        gui.chart.selectAll('line.connection')
                            .data(gui.patch.getAllConnections(this), gui.connectionKey)
                            .call(gui.setConnectionXY);
                    },

                    getText: function() { return this._guiData.text; },

                    getTextY: function() { return this.getH()/2 + gui.portletHeight/2; },

                    // Returns the height of `obj` in pixels
                    getH: function() { return 40; },

                    // Returns the width of `obj` in pixels
                    getW: function() {
                        var maxPortlet = Math.max(this.inlets.length, this.outlets.length);
                        var textLength = this.getText().length * 9;
                        return Math.max((maxPortlet-1) * 75, 75, textLength);
                    },

                    // Helper to build a key for an object for d3
                    getKey: function() {
                        return this.id;
                    },

                    d3: function() {
                        return d3.selectAll('g.objectGroup').data([this], gui.f('getKey'));
                    }

                });
            }
        }

        var portletCommon = {

            // Returns the absolute X of the portlet.
            getX: function() {
                return this.getRelX() + this.obj.getX();
            },

            // Returns the absolute Y of `outlet`.
            getY: function() {
                return this.getRelY() + this.obj.getY();
            },

            // Helper to build a key for a portlet for d3
            getKey: function() {
                return this.obj.getKey() + '-' + this.id;
            },

            _getPortletX: function(inOrOutlets) {
                var obj = this.obj;
                var L = obj.getW();
                var n = obj[inOrOutlets].length;
                if (this.id == 0) return 0;
                else if (this.id == n-1) return L - gui.portletWidth;
                else {
                    // Space between portlets
                    var a = (L-n*gui.portletWidth) / (n-1);
                    return this.id * (gui.portletWidth + a);
                }
            }

        };

        for (portletType in {'outlet': 1, 'outlet~': 1}) {

            Pd.extend(Pd[portletType].prototype, portletCommon, {

                // Returns the X of `outlet` relative to its object.
                getRelX: function() { 
                    return this._getPortletX('outlets');
                },

                // 
                getRelY: function() {
                    return this.obj.getH() - gui.portletHeight;
                }

            });
        }

        for (portletType in {'inlet': 1, 'inlet~': 1}) {

            Pd.extend(Pd[portletType].prototype, portletCommon, {

                // Returns the X of `inlet` relative to its object.
                getRelX: function() {
                    return this._getPortletX('inlets');
                },

                // 
                getRelY: function() {
                    return 0;
                }

            });
        }


        var gui = {

            patch: null,

            chart: null,

            newConnection: function(outlet, inlet) { 
                gui.eval('patch.connect(sourceObj.o(sourceId), sinkObj.i(sinkId));', {
                    sourceObj: outlet.obj,
                    sourceId: outlet.id,
                    sinkObj: inlet.obj,
                    sinkId: inlet.id,
                });
                var lines = gui.chart.selectAll('line.connection')
                    .data(gui.patch.getAllConnections(), gui.connectionKey)
                    .enter()
                    .append('line')
                    .attr('class', 'connection')
                    .call(gui.setConnectionXY)
                    .on('click', function(conn) {
                        gui.setSelection(this);
                        // Stop event propagation so that the canvas
                        // doesn't receive the click.
                        d3.event.stopPropagation();
                    });
            },

            removeConnection: function(source, sink) {
                gui.eval('patch.disconnect(sourceObj.o(sourceId), sinkObj.i(sinkId));', {
                    sinkObj: sink.obj,
                    sourceObj: source.obj,
                    sinkId: sink.id,
                    sourceId: source.id
                });
                gui.chart.selectAll('line.connection')
                    .data(gui.patch.getAllConnections(), gui.connectionKey)
                    .exit().remove();
            },

            newObject: function(objType, args) {
                // Creating object and adding it to the graph
                var obj = gui.eval('var ', 'obj = new Pd.objects[objType](patch, args);', {
                    args: args,
                    objType: objType,
                    obj: undefined
                });
                
                // Initialize the GUI infos for the new object. 
                obj.initGui(args);

                // Object group
                var gsEnter = gui.chart.selectAll('g')
                    .data(gui.patch.getAllObjects(), gui.f('getKey'))
                    .enter()
                    .append('g')
                    .attr('class', 'objectGroup')
                    .attr('transform', gui.translation(5, 5))
                    // Object selection
                    .on('click', function(obj) {
                        gui.setSelection(this);
                        // Stop event propagation so that the canvas
                        // doesn't receive the click.
                        d3.event.stopPropagation();
                    })
                    // Object dragging
                    .call(d3.behavior.drag()
                        .on('dragstart', function(obj) {})
                        .on('drag', function(obj) {
                            obj.setPos({
                                x: obj.getX() + d3.event.dx,
                                y: obj.getY() + d3.event.dy
                            });
                        })
                        .on('dragend', function(obj) {})
                    );

                // Object box
                gsEnter.append('rect')
                    .attr('class', 'object')
                    .attr('width', gui.f('getW'))
                    .attr('height', gui.f('getH'));

                // Object text
                gsEnter.append('text')
                    .attr('class', 'objectType')
                    .text(gui.f('getText'))
                    .attr('dy', gui.f('getTextY'))
                    .attr('dx', gui.portletWidth);

                // Inlets
                gsEnter
                    .selectAll('rect.inlet')
                    .data(function(obj) {return obj.inlets}, gui.f('getKey'))
                    .enter()
                    .append('rect')
                    .classed('inlet', true)
                    .classed('portlet', true)
                    .attr('width', gui.portletWidth)
                    .attr('height', gui.portletHeight)
                    .attr('x', gui.f('getRelX'))
                    .attr('y', gui.f('getRelY'));

                // Outlets
                gsEnter
                    .selectAll('rect.outlet')
                    .data(function(obj) {return obj.outlets}, gui.f('getKey'))
                    .enter()
                    .append('rect')
                    .classed('outlet', true)
                    .classed('portlet', true)
                    .attr('width', gui.portletWidth)
                    .attr('height', gui.portletHeight)
                    .attr('x', gui.f('getRelX'))
                    .attr('y', gui.f('getRelY'))
                    .call(d3.behavior.drag()
                        // Creating new connection
                        .on('dragstart', function(outlet) {
                            d3.select(this).classed('connectPortlet', true);
                            gui.chart.selectAll('rect.inlet')
                                .on('mouseover', function(inlet) {
                                    d3.select(this)
                                        .classed('connectPortlet', true)
                                        .classed('hoveredInlet', true);
                                })
                                .on('mouseout', function(inlet) {
                                    d3.select(this)
                                        .classed('connectPortlet', false)
                                        .classed('hoveredInlet', false);
                                });

                            var x = outlet.getX(), y = outlet.getY();
                            gui.chart.append('line')
                                .classed('connection', true)
                                .classed('newConnection', true)
                                .attr('x1', x + gui.portletWidth/2)
                                .attr('y1', y + gui.portletHeight)
                                .attr('x2', x + gui.portletWidth/2)
                                .attr('y2', y);
                        })
                        .on('drag', function(outlet) {
                            // update new connection
                            var conn = gui.chart.select('line.newConnection');
                            var x2 = parseInt(conn.attr('x2'), 10) + d3.event.dx;
                            var y2 = parseInt(conn.attr('y2'), 10) + d3.event.dy;
                            conn.attr('x2', x2);
                            conn.attr('y2', y2);
                        })
                        .on('dragend', function(outlet) {
                            // clean stuff set-up just for the new connection 
                            gui.chart.selectAll('rect.inlet')
                                .on('mouseover', function(inlet) {})
                                .on('mouseout', function(inlet) {});
                            d3.select(this).classed('connectPortlet', false);
                            gui.chart.select('line.newConnection').remove();
                            gui.chart.selectAll('rect.inlet').classed('connectPortlet', false);
                            // create the actual connection in the patch,
                            // and update the display.
                            d3.selectAll('.hoveredInlet')
                                .classed('hoveredInlet', false)
                                .each(function(inlet) { gui.newConnection(outlet, inlet); });
                        })

                    )
                    .on('mousedown', function() {
                        // Prevent bubbling so that drag and drop
                        // of whole object doesn't occur when creating
                        // a connection
                        d3.event.stopPropagation();
                    });

                // Click message
                if (objType == 'message') {
                    gsEnter
                        .append('circle')
                        .attr('class', 'sendMessage')
                        .attr('cx', function(obj) { return obj.getW() + 20; })
                        .attr('cy', function(obj) { return obj.getH()/2; })
                        .attr('r', 20)
                        .on('click', function(obj) {
                            gui.eval("obj.i(0).message('bang');", {obj: obj});
                            d3.event.stopPropagation();
                        });
                }

            },

            removeObject: function(obj) {
                gui.eval('patch.removeObject(obj);', {obj: obj});
                gui.chart.selectAll('g.objectGroup')
                    .data(gui.patch.getAllObjects(), gui.f('getKey'))
                    .exit().remove();
                gui.chart.selectAll('line.connection')
                    .data(gui.patch.getAllConnections(), gui.connectionKey)
                    .exit().remove();
            },

            // Object count, used only to give the objects a unique name
            // for logging
            objCount: 0,

            // This function is used to log and execute a command on the patch
            eval: function(arg1, arg2, arg3) {

                // Handling the arguments
                var toEval, toLog, context = {}, name, val;
                if (typeof arg2 == 'string') {
                    toEval = arg2;
                    toLog = arg1 + arg2;
                    if (arg3 != undefined) context = arg3;
                } else {
                    toEval = toLog = arg1;
                    context = arg2 || context;
                }
                context.patch = gui.patch;

                // Execute the command
                with (context) var result = eval(toEval);

                // Log the command in a clever way:
                // objects are replaced by a unique name, 
                // strings, arrays and numbers by their literal value
                for (name in context) {
                    val = context[name];
                    if (val == undefined) val = result;
                    if (val instanceof Pd.Object) {
                        if (val.logName == undefined) {
                            val.logName = 'obj' + gui.objCount;
                            gui.objCount++;
                        }
                        toLog = toLog.replace(name, val.logName);
                    } else if (typeof val == 'string' || typeof val == 'number'
                        || Object.prototype.toString.call(val) == '[object Array]') {
                        toLog = toLog.replace(name, JSON.stringify(val));
                    }
                }
                console.log(toLog);
                return result;
            },

            // Helper to build a translation transform for a svg object 
            translation: function(x, y) {
                return 'translate(' + x + ',' + y + ')';
            },

            // Helper to build a key for a connection for d3
            connectionKey: function(conn) {
                return ''+conn[0].obj.id+':'+conn[0].id+'-'
                        +conn[1].obj.id+':'+conn[1].id;
            },

            // Helper to update XY of a connection
            setConnectionXY: function(line) {
                line.attr('x1', function(conn) {
                        return conn[0].getX() + gui.portletWidth/2;
                    })
                    .attr('y1', function(conn) {
                        return conn[0].getY() + gui.portletHeight;
                    })
                    .attr('x2', function(conn) {
                        return conn[1].getX() + gui.portletWidth/2;
                    })
                    .attr('y2', function(conn) {
                        return conn[1].getY();
                    });
            },

            // Helper for d3, makes a function that takes an object and calls `methName` on it.
            f: function(methName) {
                return function(o) { return o[methName](); };
            },

            // Sets the current selection to `elem`
            setSelection: function(elem) {
                d3.selectAll('line.connection').classed('selected', false);
                d3.selectAll('g.objectGroup').classed('selected', false);
                if (elem != undefined) d3.select(elem).classed('selected', true);
            },

            // Deletes the current selection
            deleteSelection: function() {
                gui.chart.selectAll('.selected').each(function(thing) {
                    if (thing instanceof Pd.Object) {
                        gui.removeObject(thing);
                    } else {
                        gui.removeConnection(thing[0], thing[1]);
                    }
                });
            }
        };

        $(function() {
            gui.chart = d3.select('svg.canvas');
            gui.chart.on('click', function() { gui.setSelection(); });

            gui.patch = gui.eval('var ', 'patch = new Pd.Patch();');
            gui.eval('patch.play();');

        // Deletion of objects or connections
            $('body').keyup(function(event) {
                if (event.keyCode == 46) gui.deleteSelection();
            });
        });

        var toExpanded = function(li) {
            $('.newObject').show();
            $('.hideNewObject').hide();
            $('.newObject', li).hide();
            $('.hideNewObject', li).show();
            $('form').hide();
            $('form', li).show();
            $(li).addClass('expanded');
            $('input[type=text]', 'form').focus();
        };

        var toCollapsed = function(li) {
            $('.newObject', li).show();
            $('.hideNewObject', li).hide();
            $('form', li).hide();
            $('input[type=text]', li).val('');
            $(li).removeClass('expanded');
        };

        $(function() {
            for (objType in Pd.objects) {
                var objLiItem = $(getObjLiElem(objType));
                $('#objectsAvailable').append(objLiItem);
                toCollapsed(objLiItem);

                $(objLiItem).click(function(event) {
                    var objLiElem = $(event.currentTarget);
                    if (objLiElem.hasClass('expanded')) {
                        toCollapsed(objLiElem);
                    } else {
                        toExpanded(objLiElem);
                    }
                    event.preventDefault();
                });

                // closure to retain `objType`
                var createObjFunc = (function(objType) {
                    return function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        var form = $(event.currentTarget).parent();
                        var objLiElem = form.parent();
                        var rawArgs = $('input[type=text]', form).val();
                        rawArgs = '[' + rawArgs.split(' ').join(', ') + ']';
                        gui.newObject(objType, JSON.parse(rawArgs));
                        toCollapsed(objLiElem);
                    };
                })(objType);

                $('input', objLiItem).click(function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                });
                $('input[type=submit]', objLiItem).click(createObjFunc);
            }
        });

        function getObjLiElem(objType) {
            return '<li class="objLiElem">'
                + '<a class="newObject" href="">+</a>'
                + '<a class="hideNewObject" href="">-</a>'
                + '<span class="objType">' + objType + '</span>'
                + '<form><input type="text" /><input type="submit" value="Create" /></form>'
                + '</li>';
        }
	</script>
	<style>
        body {
            margin: 0;
            padding: 0;
        }
		.objLiElem .newObject, .objLiElem .hideNewObject {
            font-size: 150%;
            color: grey;
            font-weight: bold;
            text-decoration: none;
            margin-right: 0.5em;
            display: inline-block;
            width: 0.5em;
        }
        .objLiElem .objType {
            font-size: 125%;
            display: inline-block;
        }
        .objLiElem .newObject:hover, .objLiElem .hideNewObject:hover {
            color: LightGrey;
        }
        ul#objectsAvailable {
            background-color: white;
            padding-left: 0;
            list-style: none;
            padding-bottom: 0.1em;
            padding-top: 0.1em;
        }
        #sidebar {
            background-color: #eee;
            height: 100%;
            width: 15em;
            position: absolute;
            right: 0;
            top: 0;
        }
        .objLiElem {
            background-color: #eee;
            margin-bottom: 0.1em;
            padding-left: 0.5em;
            padding-bottom: 0.3em;
        }
        .objLiElem:hover {
            background-color: #ffe;
        }
        .objLiElem form {
            margin-bottom: 0;
        }

        .canvas {
            width: 100%;
            height: 100%;
        }
        .canvas rect.object {
            stroke: black;
            fill: white;
        }
        .canvas rect.portlet {
            stroke: #555;
            fill: #555;
        }
        .canvas rect.outlet {
            cursor: crosshair;
        }
        .canvas rect.connectPortlet {
            fill: blue;
        }
        .canvas text {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .canvas line.connection {
            stroke: black;
            stroke-width: 2px;
        }
        .canvas line.newConnection {
            stroke: blue;
            stroke-width: 2px;
        }
        .canvas line.selected, .canvas g.selected {
            stroke: blue;
            stroke-width: 3px;
        }
        .canvas circle.sendMessage:hover {
            cursor: pointer;
            fill: blue;
        }
	</style>
</head>
<body>
    <svg class="canvas">
    </svg>
    <div id="sidebar">
        <ul id="objectsAvailable">
        </ul>
    </div>
</body>
</html>
